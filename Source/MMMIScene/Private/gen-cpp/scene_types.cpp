/**
 * Autogenerated by Thrift Compiler (0.13.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef NOMINMAX
#define NOMINMAX
#endif
#include "gen-cpp/scene_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace MMIStandard {

int _kMDrawingCallTypeValues[] = {
  MDrawingCallType::DrawLine2D,
  MDrawingCallType::DrawLine3D,
  MDrawingCallType::DrawPoint2D,
  MDrawingCallType::DrawPoint3D,
  MDrawingCallType::DrawText,
  MDrawingCallType::Custom
};
const char* _kMDrawingCallTypeNames[] = {
  "DrawLine2D",
  "DrawLine3D",
  "DrawPoint2D",
  "DrawPoint3D",
  "DrawText",
  "Custom"
};
const std::map<int, const char*> _MDrawingCallType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(6, _kMDrawingCallTypeValues, _kMDrawingCallTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const MDrawingCallType::type& val) {
  std::map<int, const char*>::const_iterator it = _MDrawingCallType_VALUES_TO_NAMES.find(val);
  if (it != _MDrawingCallType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const MDrawingCallType::type& val) {
  std::map<int, const char*>::const_iterator it = _MDrawingCallType_VALUES_TO_NAMES.find(val);
  if (it != _MDrawingCallType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kMPhysicsInteractionTypeValues[] = {
  MPhysicsInteractionType::AddForce,
  MPhysicsInteractionType::AddTorque,
  MPhysicsInteractionType::ChangeVelocity,
  MPhysicsInteractionType::ChangeAngularVelocity,
  MPhysicsInteractionType::ChangeMass,
  MPhysicsInteractionType::ChangeCenterOfMass,
  MPhysicsInteractionType::ChangeInertia
};
const char* _kMPhysicsInteractionTypeNames[] = {
  "AddForce",
  "AddTorque",
  "ChangeVelocity",
  "ChangeAngularVelocity",
  "ChangeMass",
  "ChangeCenterOfMass",
  "ChangeInertia"
};
const std::map<int, const char*> _MPhysicsInteractionType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(7, _kMPhysicsInteractionTypeValues, _kMPhysicsInteractionTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const MPhysicsInteractionType::type& val) {
  std::map<int, const char*>::const_iterator it = _MPhysicsInteractionType_VALUES_TO_NAMES.find(val);
  if (it != _MPhysicsInteractionType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const MPhysicsInteractionType::type& val) {
  std::map<int, const char*>::const_iterator it = _MPhysicsInteractionType_VALUES_TO_NAMES.find(val);
  if (it != _MPhysicsInteractionType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kMColliderTypeValues[] = {
  MColliderType::Box,
  MColliderType::Sphere,
  MColliderType::Capsule,
  MColliderType::Cone,
  MColliderType::Cylinder,
  MColliderType::Mesh,
  MColliderType::Custom
};
const char* _kMColliderTypeNames[] = {
  "Box",
  "Sphere",
  "Capsule",
  "Cone",
  "Cylinder",
  "Mesh",
  "Custom"
};
const std::map<int, const char*> _MColliderType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(7, _kMColliderTypeValues, _kMColliderTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const MColliderType::type& val) {
  std::map<int, const char*>::const_iterator it = _MColliderType_VALUES_TO_NAMES.find(val);
  if (it != _MColliderType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const MColliderType::type& val) {
  std::map<int, const char*>::const_iterator it = _MColliderType_VALUES_TO_NAMES.find(val);
  if (it != _MColliderType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}


MAttachment::~MAttachment() noexcept {
}


void MAttachment::__set_Parent(const std::string& val) {
  this->Parent = val;
}

void MAttachment::__set_Child(const std::string& val) {
  this->Child = val;
}

void MAttachment::__set_Type(const std::string& val) {
  this->Type = val;
__isset.Type = true;
}
std::ostream& operator<<(std::ostream& out, const MAttachment& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t MAttachment::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_Parent = false;
  bool isset_Child = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->Parent);
          isset_Parent = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->Child);
          isset_Child = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->Type);
          this->__isset.Type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_Parent)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_Child)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t MAttachment::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MAttachment");

  xfer += oprot->writeFieldBegin("Parent", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->Parent);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("Child", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->Child);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.Type) {
    xfer += oprot->writeFieldBegin("Type", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->Type);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MAttachment &a, MAttachment &b) {
  using ::std::swap;
  swap(a.Parent, b.Parent);
  swap(a.Child, b.Child);
  swap(a.Type, b.Type);
  swap(a.__isset, b.__isset);
}

MAttachment::MAttachment(const MAttachment& other0) {
  Parent = other0.Parent;
  Child = other0.Child;
  Type = other0.Type;
  __isset = other0.__isset;
}
MAttachment& MAttachment::operator=(const MAttachment& other1) {
  Parent = other1.Parent;
  Child = other1.Child;
  Type = other1.Type;
  __isset = other1.__isset;
  return *this;
}
void MAttachment::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MAttachment(";
  out << "Parent=" << to_string(Parent);
  out << ", " << "Child=" << to_string(Child);
  out << ", " << "Type="; (__isset.Type ? (out << to_string(Type)) : (out << "<null>"));
  out << ")";
}


MAttachmentManipulation::~MAttachmentManipulation() noexcept {
}


void MAttachmentManipulation::__set_Parent(const std::string& val) {
  this->Parent = val;
}

void MAttachmentManipulation::__set_Child(const std::string& val) {
  this->Child = val;
}

void MAttachmentManipulation::__set_AddRemove(const bool val) {
  this->AddRemove = val;
}

void MAttachmentManipulation::__set_Type(const std::string& val) {
  this->Type = val;
__isset.Type = true;
}
std::ostream& operator<<(std::ostream& out, const MAttachmentManipulation& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t MAttachmentManipulation::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_Parent = false;
  bool isset_Child = false;
  bool isset_AddRemove = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->Parent);
          isset_Parent = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->Child);
          isset_Child = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->AddRemove);
          isset_AddRemove = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->Type);
          this->__isset.Type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_Parent)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_Child)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_AddRemove)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t MAttachmentManipulation::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MAttachmentManipulation");

  xfer += oprot->writeFieldBegin("Parent", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->Parent);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("Child", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->Child);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("AddRemove", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->AddRemove);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.Type) {
    xfer += oprot->writeFieldBegin("Type", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->Type);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MAttachmentManipulation &a, MAttachmentManipulation &b) {
  using ::std::swap;
  swap(a.Parent, b.Parent);
  swap(a.Child, b.Child);
  swap(a.AddRemove, b.AddRemove);
  swap(a.Type, b.Type);
  swap(a.__isset, b.__isset);
}

MAttachmentManipulation::MAttachmentManipulation(const MAttachmentManipulation& other2) {
  Parent = other2.Parent;
  Child = other2.Child;
  AddRemove = other2.AddRemove;
  Type = other2.Type;
  __isset = other2.__isset;
}
MAttachmentManipulation& MAttachmentManipulation::operator=(const MAttachmentManipulation& other3) {
  Parent = other3.Parent;
  Child = other3.Child;
  AddRemove = other3.AddRemove;
  Type = other3.Type;
  __isset = other3.__isset;
  return *this;
}
void MAttachmentManipulation::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MAttachmentManipulation(";
  out << "Parent=" << to_string(Parent);
  out << ", " << "Child=" << to_string(Child);
  out << ", " << "AddRemove=" << to_string(AddRemove);
  out << ", " << "Type="; (__isset.Type ? (out << to_string(Type)) : (out << "<null>"));
  out << ")";
}


MPropertyManipulation::~MPropertyManipulation() noexcept {
}


void MPropertyManipulation::__set_Target(const std::string& val) {
  this->Target = val;
}

void MPropertyManipulation::__set_Key(const std::string& val) {
  this->Key = val;
}

void MPropertyManipulation::__set_AddRemove(const bool val) {
  this->AddRemove = val;
}

void MPropertyManipulation::__set_Value(const std::string& val) {
  this->Value = val;
__isset.Value = true;
}
std::ostream& operator<<(std::ostream& out, const MPropertyManipulation& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t MPropertyManipulation::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_Target = false;
  bool isset_Key = false;
  bool isset_AddRemove = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->Target);
          isset_Target = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->Key);
          isset_Key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->AddRemove);
          isset_AddRemove = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->Value);
          this->__isset.Value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_Target)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_Key)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_AddRemove)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t MPropertyManipulation::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MPropertyManipulation");

  xfer += oprot->writeFieldBegin("Target", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->Target);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("Key", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->Key);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("AddRemove", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->AddRemove);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.Value) {
    xfer += oprot->writeFieldBegin("Value", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->Value);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MPropertyManipulation &a, MPropertyManipulation &b) {
  using ::std::swap;
  swap(a.Target, b.Target);
  swap(a.Key, b.Key);
  swap(a.AddRemove, b.AddRemove);
  swap(a.Value, b.Value);
  swap(a.__isset, b.__isset);
}

MPropertyManipulation::MPropertyManipulation(const MPropertyManipulation& other4) {
  Target = other4.Target;
  Key = other4.Key;
  AddRemove = other4.AddRemove;
  Value = other4.Value;
  __isset = other4.__isset;
}
MPropertyManipulation& MPropertyManipulation::operator=(const MPropertyManipulation& other5) {
  Target = other5.Target;
  Key = other5.Key;
  AddRemove = other5.AddRemove;
  Value = other5.Value;
  __isset = other5.__isset;
  return *this;
}
void MPropertyManipulation::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MPropertyManipulation(";
  out << "Target=" << to_string(Target);
  out << ", " << "Key=" << to_string(Key);
  out << ", " << "AddRemove=" << to_string(AddRemove);
  out << ", " << "Value="; (__isset.Value ? (out << to_string(Value)) : (out << "<null>"));
  out << ")";
}


MTransformUpdate::~MTransformUpdate() noexcept {
}


void MTransformUpdate::__set_Position(const std::vector<double> & val) {
  this->Position = val;
__isset.Position = true;
}

void MTransformUpdate::__set_Rotation(const std::vector<double> & val) {
  this->Rotation = val;
__isset.Rotation = true;
}

void MTransformUpdate::__set_Parent(const std::string& val) {
  this->Parent = val;
__isset.Parent = true;
}

void MTransformUpdate::__set_Scale(const std::vector<double> & val) {
  this->Scale = val;
__isset.Scale = true;
}
std::ostream& operator<<(std::ostream& out, const MTransformUpdate& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t MTransformUpdate::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->Position.clear();
            uint32_t _size6;
            ::apache::thrift::protocol::TType _etype9;
            xfer += iprot->readListBegin(_etype9, _size6);
            this->Position.resize(_size6);
            uint32_t _i10;
            for (_i10 = 0; _i10 < _size6; ++_i10)
            {
              xfer += iprot->readDouble(this->Position[_i10]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.Position = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->Rotation.clear();
            uint32_t _size11;
            ::apache::thrift::protocol::TType _etype14;
            xfer += iprot->readListBegin(_etype14, _size11);
            this->Rotation.resize(_size11);
            uint32_t _i15;
            for (_i15 = 0; _i15 < _size11; ++_i15)
            {
              xfer += iprot->readDouble(this->Rotation[_i15]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.Rotation = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->Parent);
          this->__isset.Parent = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->Scale.clear();
            uint32_t _size16;
            ::apache::thrift::protocol::TType _etype19;
            xfer += iprot->readListBegin(_etype19, _size16);
            this->Scale.resize(_size16);
            uint32_t _i20;
            for (_i20 = 0; _i20 < _size16; ++_i20)
            {
              xfer += iprot->readDouble(this->Scale[_i20]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.Scale = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MTransformUpdate::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MTransformUpdate");

  if (this->__isset.Position) {
    xfer += oprot->writeFieldBegin("Position", ::apache::thrift::protocol::T_LIST, 1);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(this->Position.size()));
      std::vector<double> ::const_iterator _iter21;
      for (_iter21 = this->Position.begin(); _iter21 != this->Position.end(); ++_iter21)
      {
        xfer += oprot->writeDouble((*_iter21));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.Rotation) {
    xfer += oprot->writeFieldBegin("Rotation", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(this->Rotation.size()));
      std::vector<double> ::const_iterator _iter22;
      for (_iter22 = this->Rotation.begin(); _iter22 != this->Rotation.end(); ++_iter22)
      {
        xfer += oprot->writeDouble((*_iter22));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.Parent) {
    xfer += oprot->writeFieldBegin("Parent", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->Parent);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.Scale) {
    xfer += oprot->writeFieldBegin("Scale", ::apache::thrift::protocol::T_LIST, 4);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(this->Scale.size()));
      std::vector<double> ::const_iterator _iter23;
      for (_iter23 = this->Scale.begin(); _iter23 != this->Scale.end(); ++_iter23)
      {
        xfer += oprot->writeDouble((*_iter23));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MTransformUpdate &a, MTransformUpdate &b) {
  using ::std::swap;
  swap(a.Position, b.Position);
  swap(a.Rotation, b.Rotation);
  swap(a.Parent, b.Parent);
  swap(a.Scale, b.Scale);
  swap(a.__isset, b.__isset);
}

MTransformUpdate::MTransformUpdate(const MTransformUpdate& other24) {
  Position = other24.Position;
  Rotation = other24.Rotation;
  Parent = other24.Parent;
  Scale = other24.Scale;
  __isset = other24.__isset;
}
MTransformUpdate& MTransformUpdate::operator=(const MTransformUpdate& other25) {
  Position = other25.Position;
  Rotation = other25.Rotation;
  Parent = other25.Parent;
  Scale = other25.Scale;
  __isset = other25.__isset;
  return *this;
}
void MTransformUpdate::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MTransformUpdate(";
  out << "Position="; (__isset.Position ? (out << to_string(Position)) : (out << "<null>"));
  out << ", " << "Rotation="; (__isset.Rotation ? (out << to_string(Rotation)) : (out << "<null>"));
  out << ", " << "Parent="; (__isset.Parent ? (out << to_string(Parent)) : (out << "<null>"));
  out << ", " << "Scale="; (__isset.Scale ? (out << to_string(Scale)) : (out << "<null>"));
  out << ")";
}


MPropertyUpdate::~MPropertyUpdate() noexcept {
}


void MPropertyUpdate::__set_Key(const std::string& val) {
  this->Key = val;
}

void MPropertyUpdate::__set_Value(const std::string& val) {
  this->Value = val;
__isset.Value = true;
}
std::ostream& operator<<(std::ostream& out, const MPropertyUpdate& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t MPropertyUpdate::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_Key = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->Key);
          isset_Key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->Value);
          this->__isset.Value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_Key)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t MPropertyUpdate::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MPropertyUpdate");

  xfer += oprot->writeFieldBegin("Key", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->Key);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.Value) {
    xfer += oprot->writeFieldBegin("Value", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->Value);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MPropertyUpdate &a, MPropertyUpdate &b) {
  using ::std::swap;
  swap(a.Key, b.Key);
  swap(a.Value, b.Value);
  swap(a.__isset, b.__isset);
}

MPropertyUpdate::MPropertyUpdate(const MPropertyUpdate& other26) {
  Key = other26.Key;
  Value = other26.Value;
  __isset = other26.__isset;
}
MPropertyUpdate& MPropertyUpdate::operator=(const MPropertyUpdate& other27) {
  Key = other27.Key;
  Value = other27.Value;
  __isset = other27.__isset;
  return *this;
}
void MPropertyUpdate::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MPropertyUpdate(";
  out << "Key=" << to_string(Key);
  out << ", " << "Value="; (__isset.Value ? (out << to_string(Value)) : (out << "<null>"));
  out << ")";
}


MPhysicsProperties::~MPhysicsProperties() noexcept {
}


void MPhysicsProperties::__set_Mass(const double val) {
  this->Mass = val;
}

void MPhysicsProperties::__set_CenterOfMass(const std::vector<double> & val) {
  this->CenterOfMass = val;
}

void MPhysicsProperties::__set_Inertia(const std::vector<double> & val) {
  this->Inertia = val;
__isset.Inertia = true;
}

void MPhysicsProperties::__set_Velocity(const std::vector<double> & val) {
  this->Velocity = val;
__isset.Velocity = true;
}

void MPhysicsProperties::__set_AngularVelocity(const std::vector<double> & val) {
  this->AngularVelocity = val;
__isset.AngularVelocity = true;
}

void MPhysicsProperties::__set_NetForce(const std::vector<double> & val) {
  this->NetForce = val;
__isset.NetForce = true;
}

void MPhysicsProperties::__set_NetTorque(const std::vector<double> & val) {
  this->NetTorque = val;
__isset.NetTorque = true;
}

void MPhysicsProperties::__set_Mu1(const double val) {
  this->Mu1 = val;
__isset.Mu1 = true;
}

void MPhysicsProperties::__set_Mu2(const double val) {
  this->Mu2 = val;
__isset.Mu2 = true;
}

void MPhysicsProperties::__set_Bounciness(const double val) {
  this->Bounciness = val;
__isset.Bounciness = true;
}

void MPhysicsProperties::__set_MuTorsion(const double val) {
  this->MuTorsion = val;
__isset.MuTorsion = true;
}

void MPhysicsProperties::__set_TorsionSurfaceRadius(const double val) {
  this->TorsionSurfaceRadius = val;
__isset.TorsionSurfaceRadius = true;
}
std::ostream& operator<<(std::ostream& out, const MPhysicsProperties& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t MPhysicsProperties::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_Mass = false;
  bool isset_CenterOfMass = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->Mass);
          isset_Mass = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->CenterOfMass.clear();
            uint32_t _size28;
            ::apache::thrift::protocol::TType _etype31;
            xfer += iprot->readListBegin(_etype31, _size28);
            this->CenterOfMass.resize(_size28);
            uint32_t _i32;
            for (_i32 = 0; _i32 < _size28; ++_i32)
            {
              xfer += iprot->readDouble(this->CenterOfMass[_i32]);
            }
            xfer += iprot->readListEnd();
          }
          isset_CenterOfMass = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->Inertia.clear();
            uint32_t _size33;
            ::apache::thrift::protocol::TType _etype36;
            xfer += iprot->readListBegin(_etype36, _size33);
            this->Inertia.resize(_size33);
            uint32_t _i37;
            for (_i37 = 0; _i37 < _size33; ++_i37)
            {
              xfer += iprot->readDouble(this->Inertia[_i37]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.Inertia = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->Velocity.clear();
            uint32_t _size38;
            ::apache::thrift::protocol::TType _etype41;
            xfer += iprot->readListBegin(_etype41, _size38);
            this->Velocity.resize(_size38);
            uint32_t _i42;
            for (_i42 = 0; _i42 < _size38; ++_i42)
            {
              xfer += iprot->readDouble(this->Velocity[_i42]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.Velocity = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->AngularVelocity.clear();
            uint32_t _size43;
            ::apache::thrift::protocol::TType _etype46;
            xfer += iprot->readListBegin(_etype46, _size43);
            this->AngularVelocity.resize(_size43);
            uint32_t _i47;
            for (_i47 = 0; _i47 < _size43; ++_i47)
            {
              xfer += iprot->readDouble(this->AngularVelocity[_i47]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.AngularVelocity = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->NetForce.clear();
            uint32_t _size48;
            ::apache::thrift::protocol::TType _etype51;
            xfer += iprot->readListBegin(_etype51, _size48);
            this->NetForce.resize(_size48);
            uint32_t _i52;
            for (_i52 = 0; _i52 < _size48; ++_i52)
            {
              xfer += iprot->readDouble(this->NetForce[_i52]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.NetForce = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->NetTorque.clear();
            uint32_t _size53;
            ::apache::thrift::protocol::TType _etype56;
            xfer += iprot->readListBegin(_etype56, _size53);
            this->NetTorque.resize(_size53);
            uint32_t _i57;
            for (_i57 = 0; _i57 < _size53; ++_i57)
            {
              xfer += iprot->readDouble(this->NetTorque[_i57]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.NetTorque = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->Mu1);
          this->__isset.Mu1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->Mu2);
          this->__isset.Mu2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->Bounciness);
          this->__isset.Bounciness = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->MuTorsion);
          this->__isset.MuTorsion = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->TorsionSurfaceRadius);
          this->__isset.TorsionSurfaceRadius = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_Mass)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_CenterOfMass)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t MPhysicsProperties::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MPhysicsProperties");

  xfer += oprot->writeFieldBegin("Mass", ::apache::thrift::protocol::T_DOUBLE, 1);
  xfer += oprot->writeDouble(this->Mass);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("CenterOfMass", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(this->CenterOfMass.size()));
    std::vector<double> ::const_iterator _iter58;
    for (_iter58 = this->CenterOfMass.begin(); _iter58 != this->CenterOfMass.end(); ++_iter58)
    {
      xfer += oprot->writeDouble((*_iter58));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.Inertia) {
    xfer += oprot->writeFieldBegin("Inertia", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(this->Inertia.size()));
      std::vector<double> ::const_iterator _iter59;
      for (_iter59 = this->Inertia.begin(); _iter59 != this->Inertia.end(); ++_iter59)
      {
        xfer += oprot->writeDouble((*_iter59));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.Velocity) {
    xfer += oprot->writeFieldBegin("Velocity", ::apache::thrift::protocol::T_LIST, 4);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(this->Velocity.size()));
      std::vector<double> ::const_iterator _iter60;
      for (_iter60 = this->Velocity.begin(); _iter60 != this->Velocity.end(); ++_iter60)
      {
        xfer += oprot->writeDouble((*_iter60));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.AngularVelocity) {
    xfer += oprot->writeFieldBegin("AngularVelocity", ::apache::thrift::protocol::T_LIST, 5);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(this->AngularVelocity.size()));
      std::vector<double> ::const_iterator _iter61;
      for (_iter61 = this->AngularVelocity.begin(); _iter61 != this->AngularVelocity.end(); ++_iter61)
      {
        xfer += oprot->writeDouble((*_iter61));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.NetForce) {
    xfer += oprot->writeFieldBegin("NetForce", ::apache::thrift::protocol::T_LIST, 6);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(this->NetForce.size()));
      std::vector<double> ::const_iterator _iter62;
      for (_iter62 = this->NetForce.begin(); _iter62 != this->NetForce.end(); ++_iter62)
      {
        xfer += oprot->writeDouble((*_iter62));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.NetTorque) {
    xfer += oprot->writeFieldBegin("NetTorque", ::apache::thrift::protocol::T_LIST, 7);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(this->NetTorque.size()));
      std::vector<double> ::const_iterator _iter63;
      for (_iter63 = this->NetTorque.begin(); _iter63 != this->NetTorque.end(); ++_iter63)
      {
        xfer += oprot->writeDouble((*_iter63));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.Mu1) {
    xfer += oprot->writeFieldBegin("Mu1", ::apache::thrift::protocol::T_DOUBLE, 8);
    xfer += oprot->writeDouble(this->Mu1);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.Mu2) {
    xfer += oprot->writeFieldBegin("Mu2", ::apache::thrift::protocol::T_DOUBLE, 9);
    xfer += oprot->writeDouble(this->Mu2);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.Bounciness) {
    xfer += oprot->writeFieldBegin("Bounciness", ::apache::thrift::protocol::T_DOUBLE, 10);
    xfer += oprot->writeDouble(this->Bounciness);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.MuTorsion) {
    xfer += oprot->writeFieldBegin("MuTorsion", ::apache::thrift::protocol::T_DOUBLE, 11);
    xfer += oprot->writeDouble(this->MuTorsion);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.TorsionSurfaceRadius) {
    xfer += oprot->writeFieldBegin("TorsionSurfaceRadius", ::apache::thrift::protocol::T_DOUBLE, 12);
    xfer += oprot->writeDouble(this->TorsionSurfaceRadius);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MPhysicsProperties &a, MPhysicsProperties &b) {
  using ::std::swap;
  swap(a.Mass, b.Mass);
  swap(a.CenterOfMass, b.CenterOfMass);
  swap(a.Inertia, b.Inertia);
  swap(a.Velocity, b.Velocity);
  swap(a.AngularVelocity, b.AngularVelocity);
  swap(a.NetForce, b.NetForce);
  swap(a.NetTorque, b.NetTorque);
  swap(a.Mu1, b.Mu1);
  swap(a.Mu2, b.Mu2);
  swap(a.Bounciness, b.Bounciness);
  swap(a.MuTorsion, b.MuTorsion);
  swap(a.TorsionSurfaceRadius, b.TorsionSurfaceRadius);
  swap(a.__isset, b.__isset);
}

MPhysicsProperties::MPhysicsProperties(const MPhysicsProperties& other64) {
  Mass = other64.Mass;
  CenterOfMass = other64.CenterOfMass;
  Inertia = other64.Inertia;
  Velocity = other64.Velocity;
  AngularVelocity = other64.AngularVelocity;
  NetForce = other64.NetForce;
  NetTorque = other64.NetTorque;
  Mu1 = other64.Mu1;
  Mu2 = other64.Mu2;
  Bounciness = other64.Bounciness;
  MuTorsion = other64.MuTorsion;
  TorsionSurfaceRadius = other64.TorsionSurfaceRadius;
  __isset = other64.__isset;
}
MPhysicsProperties& MPhysicsProperties::operator=(const MPhysicsProperties& other65) {
  Mass = other65.Mass;
  CenterOfMass = other65.CenterOfMass;
  Inertia = other65.Inertia;
  Velocity = other65.Velocity;
  AngularVelocity = other65.AngularVelocity;
  NetForce = other65.NetForce;
  NetTorque = other65.NetTorque;
  Mu1 = other65.Mu1;
  Mu2 = other65.Mu2;
  Bounciness = other65.Bounciness;
  MuTorsion = other65.MuTorsion;
  TorsionSurfaceRadius = other65.TorsionSurfaceRadius;
  __isset = other65.__isset;
  return *this;
}
void MPhysicsProperties::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MPhysicsProperties(";
  out << "Mass=" << to_string(Mass);
  out << ", " << "CenterOfMass=" << to_string(CenterOfMass);
  out << ", " << "Inertia="; (__isset.Inertia ? (out << to_string(Inertia)) : (out << "<null>"));
  out << ", " << "Velocity="; (__isset.Velocity ? (out << to_string(Velocity)) : (out << "<null>"));
  out << ", " << "AngularVelocity="; (__isset.AngularVelocity ? (out << to_string(AngularVelocity)) : (out << "<null>"));
  out << ", " << "NetForce="; (__isset.NetForce ? (out << to_string(NetForce)) : (out << "<null>"));
  out << ", " << "NetTorque="; (__isset.NetTorque ? (out << to_string(NetTorque)) : (out << "<null>"));
  out << ", " << "Mu1="; (__isset.Mu1 ? (out << to_string(Mu1)) : (out << "<null>"));
  out << ", " << "Mu2="; (__isset.Mu2 ? (out << to_string(Mu2)) : (out << "<null>"));
  out << ", " << "Bounciness="; (__isset.Bounciness ? (out << to_string(Bounciness)) : (out << "<null>"));
  out << ", " << "MuTorsion="; (__isset.MuTorsion ? (out << to_string(MuTorsion)) : (out << "<null>"));
  out << ", " << "TorsionSurfaceRadius="; (__isset.TorsionSurfaceRadius ? (out << to_string(TorsionSurfaceRadius)) : (out << "<null>"));
  out << ")";
}


MSphereColliderProperties::~MSphereColliderProperties() noexcept {
}


void MSphereColliderProperties::__set_Radius(const double val) {
  this->Radius = val;
}
std::ostream& operator<<(std::ostream& out, const MSphereColliderProperties& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t MSphereColliderProperties::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_Radius = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->Radius);
          isset_Radius = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_Radius)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t MSphereColliderProperties::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MSphereColliderProperties");

  xfer += oprot->writeFieldBegin("Radius", ::apache::thrift::protocol::T_DOUBLE, 1);
  xfer += oprot->writeDouble(this->Radius);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MSphereColliderProperties &a, MSphereColliderProperties &b) {
  using ::std::swap;
  swap(a.Radius, b.Radius);
}

MSphereColliderProperties::MSphereColliderProperties(const MSphereColliderProperties& other66) {
  Radius = other66.Radius;
}
MSphereColliderProperties& MSphereColliderProperties::operator=(const MSphereColliderProperties& other67) {
  Radius = other67.Radius;
  return *this;
}
void MSphereColliderProperties::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MSphereColliderProperties(";
  out << "Radius=" << to_string(Radius);
  out << ")";
}


MConeColliderProperties::~MConeColliderProperties() noexcept {
}


void MConeColliderProperties::__set_Radius(const double val) {
  this->Radius = val;
}

void MConeColliderProperties::__set_Height(const double val) {
  this->Height = val;
}
std::ostream& operator<<(std::ostream& out, const MConeColliderProperties& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t MConeColliderProperties::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_Radius = false;
  bool isset_Height = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->Radius);
          isset_Radius = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->Height);
          isset_Height = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_Radius)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_Height)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t MConeColliderProperties::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MConeColliderProperties");

  xfer += oprot->writeFieldBegin("Radius", ::apache::thrift::protocol::T_DOUBLE, 1);
  xfer += oprot->writeDouble(this->Radius);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("Height", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->Height);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MConeColliderProperties &a, MConeColliderProperties &b) {
  using ::std::swap;
  swap(a.Radius, b.Radius);
  swap(a.Height, b.Height);
}

MConeColliderProperties::MConeColliderProperties(const MConeColliderProperties& other68) {
  Radius = other68.Radius;
  Height = other68.Height;
}
MConeColliderProperties& MConeColliderProperties::operator=(const MConeColliderProperties& other69) {
  Radius = other69.Radius;
  Height = other69.Height;
  return *this;
}
void MConeColliderProperties::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MConeColliderProperties(";
  out << "Radius=" << to_string(Radius);
  out << ", " << "Height=" << to_string(Height);
  out << ")";
}


MCylinderColliderProperties::~MCylinderColliderProperties() noexcept {
}


void MCylinderColliderProperties::__set_Radius(const double val) {
  this->Radius = val;
}

void MCylinderColliderProperties::__set_Height(const double val) {
  this->Height = val;
}
std::ostream& operator<<(std::ostream& out, const MCylinderColliderProperties& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t MCylinderColliderProperties::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_Radius = false;
  bool isset_Height = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->Radius);
          isset_Radius = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->Height);
          isset_Height = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_Radius)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_Height)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t MCylinderColliderProperties::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MCylinderColliderProperties");

  xfer += oprot->writeFieldBegin("Radius", ::apache::thrift::protocol::T_DOUBLE, 1);
  xfer += oprot->writeDouble(this->Radius);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("Height", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->Height);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MCylinderColliderProperties &a, MCylinderColliderProperties &b) {
  using ::std::swap;
  swap(a.Radius, b.Radius);
  swap(a.Height, b.Height);
}

MCylinderColliderProperties::MCylinderColliderProperties(const MCylinderColliderProperties& other70) {
  Radius = other70.Radius;
  Height = other70.Height;
}
MCylinderColliderProperties& MCylinderColliderProperties::operator=(const MCylinderColliderProperties& other71) {
  Radius = other71.Radius;
  Height = other71.Height;
  return *this;
}
void MCylinderColliderProperties::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MCylinderColliderProperties(";
  out << "Radius=" << to_string(Radius);
  out << ", " << "Height=" << to_string(Height);
  out << ")";
}


MTransformManipulation::~MTransformManipulation() noexcept {
}


void MTransformManipulation::__set_Target(const std::string& val) {
  this->Target = val;
}

void MTransformManipulation::__set_Position(const  ::MMIStandard::MVector3& val) {
  this->Position = val;
__isset.Position = true;
}

void MTransformManipulation::__set_Rotation(const  ::MMIStandard::MQuaternion& val) {
  this->Rotation = val;
__isset.Rotation = true;
}

void MTransformManipulation::__set_Parent(const std::string& val) {
  this->Parent = val;
__isset.Parent = true;
}
std::ostream& operator<<(std::ostream& out, const MTransformManipulation& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t MTransformManipulation::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_Target = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->Target);
          isset_Target = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->Position.read(iprot);
          this->__isset.Position = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->Rotation.read(iprot);
          this->__isset.Rotation = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->Parent);
          this->__isset.Parent = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_Target)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t MTransformManipulation::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MTransformManipulation");

  xfer += oprot->writeFieldBegin("Target", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->Target);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.Position) {
    xfer += oprot->writeFieldBegin("Position", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->Position.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.Rotation) {
    xfer += oprot->writeFieldBegin("Rotation", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->Rotation.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.Parent) {
    xfer += oprot->writeFieldBegin("Parent", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->Parent);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MTransformManipulation &a, MTransformManipulation &b) {
  using ::std::swap;
  swap(a.Target, b.Target);
  swap(a.Position, b.Position);
  swap(a.Rotation, b.Rotation);
  swap(a.Parent, b.Parent);
  swap(a.__isset, b.__isset);
}

MTransformManipulation::MTransformManipulation(const MTransformManipulation& other72) {
  Target = other72.Target;
  Position = other72.Position;
  Rotation = other72.Rotation;
  Parent = other72.Parent;
  __isset = other72.__isset;
}
MTransformManipulation& MTransformManipulation::operator=(const MTransformManipulation& other73) {
  Target = other73.Target;
  Position = other73.Position;
  Rotation = other73.Rotation;
  Parent = other73.Parent;
  __isset = other73.__isset;
  return *this;
}
void MTransformManipulation::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MTransformManipulation(";
  out << "Target=" << to_string(Target);
  out << ", " << "Position="; (__isset.Position ? (out << to_string(Position)) : (out << "<null>"));
  out << ", " << "Rotation="; (__isset.Rotation ? (out << to_string(Rotation)) : (out << "<null>"));
  out << ", " << "Parent="; (__isset.Parent ? (out << to_string(Parent)) : (out << "<null>"));
  out << ")";
}


MBoxColliderProperties::~MBoxColliderProperties() noexcept {
}


void MBoxColliderProperties::__set_Size(const  ::MMIStandard::MVector3& val) {
  this->Size = val;
}
std::ostream& operator<<(std::ostream& out, const MBoxColliderProperties& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t MBoxColliderProperties::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_Size = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->Size.read(iprot);
          isset_Size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_Size)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t MBoxColliderProperties::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MBoxColliderProperties");

  xfer += oprot->writeFieldBegin("Size", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->Size.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MBoxColliderProperties &a, MBoxColliderProperties &b) {
  using ::std::swap;
  swap(a.Size, b.Size);
}

MBoxColliderProperties::MBoxColliderProperties(const MBoxColliderProperties& other74) {
  Size = other74.Size;
}
MBoxColliderProperties& MBoxColliderProperties::operator=(const MBoxColliderProperties& other75) {
  Size = other75.Size;
  return *this;
}
void MBoxColliderProperties::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MBoxColliderProperties(";
  out << "Size=" << to_string(Size);
  out << ")";
}


MCapsuleColliderProperties::~MCapsuleColliderProperties() noexcept {
}


void MCapsuleColliderProperties::__set_Radius(const double val) {
  this->Radius = val;
}

void MCapsuleColliderProperties::__set_Height(const double val) {
  this->Height = val;
}

void MCapsuleColliderProperties::__set_MainAxis(const  ::MMIStandard::MVector3& val) {
  this->MainAxis = val;
__isset.MainAxis = true;
}
std::ostream& operator<<(std::ostream& out, const MCapsuleColliderProperties& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t MCapsuleColliderProperties::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_Radius = false;
  bool isset_Height = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->Radius);
          isset_Radius = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->Height);
          isset_Height = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->MainAxis.read(iprot);
          this->__isset.MainAxis = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_Radius)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_Height)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t MCapsuleColliderProperties::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MCapsuleColliderProperties");

  xfer += oprot->writeFieldBegin("Radius", ::apache::thrift::protocol::T_DOUBLE, 1);
  xfer += oprot->writeDouble(this->Radius);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("Height", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->Height);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.MainAxis) {
    xfer += oprot->writeFieldBegin("MainAxis", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->MainAxis.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MCapsuleColliderProperties &a, MCapsuleColliderProperties &b) {
  using ::std::swap;
  swap(a.Radius, b.Radius);
  swap(a.Height, b.Height);
  swap(a.MainAxis, b.MainAxis);
  swap(a.__isset, b.__isset);
}

MCapsuleColliderProperties::MCapsuleColliderProperties(const MCapsuleColliderProperties& other76) {
  Radius = other76.Radius;
  Height = other76.Height;
  MainAxis = other76.MainAxis;
  __isset = other76.__isset;
}
MCapsuleColliderProperties& MCapsuleColliderProperties::operator=(const MCapsuleColliderProperties& other77) {
  Radius = other77.Radius;
  Height = other77.Height;
  MainAxis = other77.MainAxis;
  __isset = other77.__isset;
  return *this;
}
void MCapsuleColliderProperties::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MCapsuleColliderProperties(";
  out << "Radius=" << to_string(Radius);
  out << ", " << "Height=" << to_string(Height);
  out << ", " << "MainAxis="; (__isset.MainAxis ? (out << to_string(MainAxis)) : (out << "<null>"));
  out << ")";
}


MMeshColliderProperties::~MMeshColliderProperties() noexcept {
}


void MMeshColliderProperties::__set_Vertices(const std::vector< ::MMIStandard::MVector3> & val) {
  this->Vertices = val;
}

void MMeshColliderProperties::__set_Triangles(const std::vector<int32_t> & val) {
  this->Triangles = val;
}
std::ostream& operator<<(std::ostream& out, const MMeshColliderProperties& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t MMeshColliderProperties::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_Vertices = false;
  bool isset_Triangles = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->Vertices.clear();
            uint32_t _size78;
            ::apache::thrift::protocol::TType _etype81;
            xfer += iprot->readListBegin(_etype81, _size78);
            this->Vertices.resize(_size78);
            uint32_t _i82;
            for (_i82 = 0; _i82 < _size78; ++_i82)
            {
              xfer += this->Vertices[_i82].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_Vertices = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->Triangles.clear();
            uint32_t _size83;
            ::apache::thrift::protocol::TType _etype86;
            xfer += iprot->readListBegin(_etype86, _size83);
            this->Triangles.resize(_size83);
            uint32_t _i87;
            for (_i87 = 0; _i87 < _size83; ++_i87)
            {
              xfer += iprot->readI32(this->Triangles[_i87]);
            }
            xfer += iprot->readListEnd();
          }
          isset_Triangles = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_Vertices)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_Triangles)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t MMeshColliderProperties::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MMeshColliderProperties");

  xfer += oprot->writeFieldBegin("Vertices", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->Vertices.size()));
    std::vector< ::MMIStandard::MVector3> ::const_iterator _iter88;
    for (_iter88 = this->Vertices.begin(); _iter88 != this->Vertices.end(); ++_iter88)
    {
      xfer += (*_iter88).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("Triangles", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->Triangles.size()));
    std::vector<int32_t> ::const_iterator _iter89;
    for (_iter89 = this->Triangles.begin(); _iter89 != this->Triangles.end(); ++_iter89)
    {
      xfer += oprot->writeI32((*_iter89));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MMeshColliderProperties &a, MMeshColliderProperties &b) {
  using ::std::swap;
  swap(a.Vertices, b.Vertices);
  swap(a.Triangles, b.Triangles);
}

MMeshColliderProperties::MMeshColliderProperties(const MMeshColliderProperties& other90) {
  Vertices = other90.Vertices;
  Triangles = other90.Triangles;
}
MMeshColliderProperties& MMeshColliderProperties::operator=(const MMeshColliderProperties& other91) {
  Vertices = other91.Vertices;
  Triangles = other91.Triangles;
  return *this;
}
void MMeshColliderProperties::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MMeshColliderProperties(";
  out << "Vertices=" << to_string(Vertices);
  out << ", " << "Triangles=" << to_string(Triangles);
  out << ")";
}


MMesh::~MMesh() noexcept {
}


void MMesh::__set_ID(const std::string& val) {
  this->ID = val;
}

void MMesh::__set_Vertices(const std::vector< ::MMIStandard::MVector3> & val) {
  this->Vertices = val;
}

void MMesh::__set_Triangles(const std::vector<int32_t> & val) {
  this->Triangles = val;
}

void MMesh::__set_UVCoordinates(const std::vector< ::MMIStandard::MVector2> & val) {
  this->UVCoordinates = val;
__isset.UVCoordinates = true;
}

void MMesh::__set_Properties(const std::map<std::string, std::string> & val) {
  this->Properties = val;
__isset.Properties = true;
}
std::ostream& operator<<(std::ostream& out, const MMesh& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t MMesh::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_ID = false;
  bool isset_Vertices = false;
  bool isset_Triangles = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ID);
          isset_ID = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->Vertices.clear();
            uint32_t _size92;
            ::apache::thrift::protocol::TType _etype95;
            xfer += iprot->readListBegin(_etype95, _size92);
            this->Vertices.resize(_size92);
            uint32_t _i96;
            for (_i96 = 0; _i96 < _size92; ++_i96)
            {
              xfer += this->Vertices[_i96].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_Vertices = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->Triangles.clear();
            uint32_t _size97;
            ::apache::thrift::protocol::TType _etype100;
            xfer += iprot->readListBegin(_etype100, _size97);
            this->Triangles.resize(_size97);
            uint32_t _i101;
            for (_i101 = 0; _i101 < _size97; ++_i101)
            {
              xfer += iprot->readI32(this->Triangles[_i101]);
            }
            xfer += iprot->readListEnd();
          }
          isset_Triangles = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->UVCoordinates.clear();
            uint32_t _size102;
            ::apache::thrift::protocol::TType _etype105;
            xfer += iprot->readListBegin(_etype105, _size102);
            this->UVCoordinates.resize(_size102);
            uint32_t _i106;
            for (_i106 = 0; _i106 < _size102; ++_i106)
            {
              xfer += this->UVCoordinates[_i106].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.UVCoordinates = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->Properties.clear();
            uint32_t _size107;
            ::apache::thrift::protocol::TType _ktype108;
            ::apache::thrift::protocol::TType _vtype109;
            xfer += iprot->readMapBegin(_ktype108, _vtype109, _size107);
            uint32_t _i111;
            for (_i111 = 0; _i111 < _size107; ++_i111)
            {
              std::string _key112;
              xfer += iprot->readString(_key112);
              std::string& _val113 = this->Properties[_key112];
              xfer += iprot->readString(_val113);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.Properties = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_ID)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_Vertices)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_Triangles)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t MMesh::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MMesh");

  xfer += oprot->writeFieldBegin("ID", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->ID);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("Vertices", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->Vertices.size()));
    std::vector< ::MMIStandard::MVector3> ::const_iterator _iter114;
    for (_iter114 = this->Vertices.begin(); _iter114 != this->Vertices.end(); ++_iter114)
    {
      xfer += (*_iter114).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("Triangles", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->Triangles.size()));
    std::vector<int32_t> ::const_iterator _iter115;
    for (_iter115 = this->Triangles.begin(); _iter115 != this->Triangles.end(); ++_iter115)
    {
      xfer += oprot->writeI32((*_iter115));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.UVCoordinates) {
    xfer += oprot->writeFieldBegin("UVCoordinates", ::apache::thrift::protocol::T_LIST, 4);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->UVCoordinates.size()));
      std::vector< ::MMIStandard::MVector2> ::const_iterator _iter116;
      for (_iter116 = this->UVCoordinates.begin(); _iter116 != this->UVCoordinates.end(); ++_iter116)
      {
        xfer += (*_iter116).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.Properties) {
    xfer += oprot->writeFieldBegin("Properties", ::apache::thrift::protocol::T_MAP, 5);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->Properties.size()));
      std::map<std::string, std::string> ::const_iterator _iter117;
      for (_iter117 = this->Properties.begin(); _iter117 != this->Properties.end(); ++_iter117)
      {
        xfer += oprot->writeString(_iter117->first);
        xfer += oprot->writeString(_iter117->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MMesh &a, MMesh &b) {
  using ::std::swap;
  swap(a.ID, b.ID);
  swap(a.Vertices, b.Vertices);
  swap(a.Triangles, b.Triangles);
  swap(a.UVCoordinates, b.UVCoordinates);
  swap(a.Properties, b.Properties);
  swap(a.__isset, b.__isset);
}

MMesh::MMesh(const MMesh& other118) {
  ID = other118.ID;
  Vertices = other118.Vertices;
  Triangles = other118.Triangles;
  UVCoordinates = other118.UVCoordinates;
  Properties = other118.Properties;
  __isset = other118.__isset;
}
MMesh& MMesh::operator=(const MMesh& other119) {
  ID = other119.ID;
  Vertices = other119.Vertices;
  Triangles = other119.Triangles;
  UVCoordinates = other119.UVCoordinates;
  Properties = other119.Properties;
  __isset = other119.__isset;
  return *this;
}
void MMesh::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MMesh(";
  out << "ID=" << to_string(ID);
  out << ", " << "Vertices=" << to_string(Vertices);
  out << ", " << "Triangles=" << to_string(Triangles);
  out << ", " << "UVCoordinates="; (__isset.UVCoordinates ? (out << to_string(UVCoordinates)) : (out << "<null>"));
  out << ", " << "Properties="; (__isset.Properties ? (out << to_string(Properties)) : (out << "<null>"));
  out << ")";
}


MNavigationMesh::~MNavigationMesh() noexcept {
}


void MNavigationMesh::__set_Vertices(const std::vector< ::MMIStandard::MVector3> & val) {
  this->Vertices = val;
}

void MNavigationMesh::__set_Triangles(const std::vector<int32_t> & val) {
  this->Triangles = val;
}

void MNavigationMesh::__set_Properties(const std::map<std::string, std::string> & val) {
  this->Properties = val;
__isset.Properties = true;
}
std::ostream& operator<<(std::ostream& out, const MNavigationMesh& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t MNavigationMesh::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_Vertices = false;
  bool isset_Triangles = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->Vertices.clear();
            uint32_t _size120;
            ::apache::thrift::protocol::TType _etype123;
            xfer += iprot->readListBegin(_etype123, _size120);
            this->Vertices.resize(_size120);
            uint32_t _i124;
            for (_i124 = 0; _i124 < _size120; ++_i124)
            {
              xfer += this->Vertices[_i124].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_Vertices = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->Triangles.clear();
            uint32_t _size125;
            ::apache::thrift::protocol::TType _etype128;
            xfer += iprot->readListBegin(_etype128, _size125);
            this->Triangles.resize(_size125);
            uint32_t _i129;
            for (_i129 = 0; _i129 < _size125; ++_i129)
            {
              xfer += iprot->readI32(this->Triangles[_i129]);
            }
            xfer += iprot->readListEnd();
          }
          isset_Triangles = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->Properties.clear();
            uint32_t _size130;
            ::apache::thrift::protocol::TType _ktype131;
            ::apache::thrift::protocol::TType _vtype132;
            xfer += iprot->readMapBegin(_ktype131, _vtype132, _size130);
            uint32_t _i134;
            for (_i134 = 0; _i134 < _size130; ++_i134)
            {
              std::string _key135;
              xfer += iprot->readString(_key135);
              std::string& _val136 = this->Properties[_key135];
              xfer += iprot->readString(_val136);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.Properties = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_Vertices)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_Triangles)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t MNavigationMesh::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MNavigationMesh");

  xfer += oprot->writeFieldBegin("Vertices", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->Vertices.size()));
    std::vector< ::MMIStandard::MVector3> ::const_iterator _iter137;
    for (_iter137 = this->Vertices.begin(); _iter137 != this->Vertices.end(); ++_iter137)
    {
      xfer += (*_iter137).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("Triangles", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->Triangles.size()));
    std::vector<int32_t> ::const_iterator _iter138;
    for (_iter138 = this->Triangles.begin(); _iter138 != this->Triangles.end(); ++_iter138)
    {
      xfer += oprot->writeI32((*_iter138));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.Properties) {
    xfer += oprot->writeFieldBegin("Properties", ::apache::thrift::protocol::T_MAP, 3);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->Properties.size()));
      std::map<std::string, std::string> ::const_iterator _iter139;
      for (_iter139 = this->Properties.begin(); _iter139 != this->Properties.end(); ++_iter139)
      {
        xfer += oprot->writeString(_iter139->first);
        xfer += oprot->writeString(_iter139->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MNavigationMesh &a, MNavigationMesh &b) {
  using ::std::swap;
  swap(a.Vertices, b.Vertices);
  swap(a.Triangles, b.Triangles);
  swap(a.Properties, b.Properties);
  swap(a.__isset, b.__isset);
}

MNavigationMesh::MNavigationMesh(const MNavigationMesh& other140) {
  Vertices = other140.Vertices;
  Triangles = other140.Triangles;
  Properties = other140.Properties;
  __isset = other140.__isset;
}
MNavigationMesh& MNavigationMesh::operator=(const MNavigationMesh& other141) {
  Vertices = other141.Vertices;
  Triangles = other141.Triangles;
  Properties = other141.Properties;
  __isset = other141.__isset;
  return *this;
}
void MNavigationMesh::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MNavigationMesh(";
  out << "Vertices=" << to_string(Vertices);
  out << ", " << "Triangles=" << to_string(Triangles);
  out << ", " << "Properties="; (__isset.Properties ? (out << to_string(Properties)) : (out << "<null>"));
  out << ")";
}


MDrawingCall::~MDrawingCall() noexcept {
}


void MDrawingCall::__set_Type(const MDrawingCallType::type val) {
  this->Type = val;
}

void MDrawingCall::__set_Data(const std::vector<double> & val) {
  this->Data = val;
__isset.Data = true;
}

void MDrawingCall::__set_Properties(const std::map<std::string, std::string> & val) {
  this->Properties = val;
__isset.Properties = true;
}
std::ostream& operator<<(std::ostream& out, const MDrawingCall& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t MDrawingCall::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_Type = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast142;
          xfer += iprot->readI32(ecast142);
          this->Type = (MDrawingCallType::type)ecast142;
          isset_Type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->Data.clear();
            uint32_t _size143;
            ::apache::thrift::protocol::TType _etype146;
            xfer += iprot->readListBegin(_etype146, _size143);
            this->Data.resize(_size143);
            uint32_t _i147;
            for (_i147 = 0; _i147 < _size143; ++_i147)
            {
              xfer += iprot->readDouble(this->Data[_i147]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.Data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->Properties.clear();
            uint32_t _size148;
            ::apache::thrift::protocol::TType _ktype149;
            ::apache::thrift::protocol::TType _vtype150;
            xfer += iprot->readMapBegin(_ktype149, _vtype150, _size148);
            uint32_t _i152;
            for (_i152 = 0; _i152 < _size148; ++_i152)
            {
              std::string _key153;
              xfer += iprot->readString(_key153);
              std::string& _val154 = this->Properties[_key153];
              xfer += iprot->readString(_val154);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.Properties = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_Type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t MDrawingCall::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MDrawingCall");

  xfer += oprot->writeFieldBegin("Type", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->Type);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.Data) {
    xfer += oprot->writeFieldBegin("Data", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(this->Data.size()));
      std::vector<double> ::const_iterator _iter155;
      for (_iter155 = this->Data.begin(); _iter155 != this->Data.end(); ++_iter155)
      {
        xfer += oprot->writeDouble((*_iter155));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.Properties) {
    xfer += oprot->writeFieldBegin("Properties", ::apache::thrift::protocol::T_MAP, 3);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->Properties.size()));
      std::map<std::string, std::string> ::const_iterator _iter156;
      for (_iter156 = this->Properties.begin(); _iter156 != this->Properties.end(); ++_iter156)
      {
        xfer += oprot->writeString(_iter156->first);
        xfer += oprot->writeString(_iter156->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MDrawingCall &a, MDrawingCall &b) {
  using ::std::swap;
  swap(a.Type, b.Type);
  swap(a.Data, b.Data);
  swap(a.Properties, b.Properties);
  swap(a.__isset, b.__isset);
}

MDrawingCall::MDrawingCall(const MDrawingCall& other157) {
  Type = other157.Type;
  Data = other157.Data;
  Properties = other157.Properties;
  __isset = other157.__isset;
}
MDrawingCall& MDrawingCall::operator=(const MDrawingCall& other158) {
  Type = other158.Type;
  Data = other158.Data;
  Properties = other158.Properties;
  __isset = other158.__isset;
  return *this;
}
void MDrawingCall::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MDrawingCall(";
  out << "Type=" << to_string(Type);
  out << ", " << "Data="; (__isset.Data ? (out << to_string(Data)) : (out << "<null>"));
  out << ", " << "Properties="; (__isset.Properties ? (out << to_string(Properties)) : (out << "<null>"));
  out << ")";
}


MPhysicsInteraction::~MPhysicsInteraction() noexcept {
}


void MPhysicsInteraction::__set_Target(const std::string& val) {
  this->Target = val;
}

void MPhysicsInteraction::__set_Type(const MPhysicsInteractionType::type val) {
  this->Type = val;
}

void MPhysicsInteraction::__set_Values(const std::vector<double> & val) {
  this->Values = val;
}

void MPhysicsInteraction::__set_Properties(const std::map<std::string, std::string> & val) {
  this->Properties = val;
__isset.Properties = true;
}
std::ostream& operator<<(std::ostream& out, const MPhysicsInteraction& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t MPhysicsInteraction::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_Target = false;
  bool isset_Type = false;
  bool isset_Values = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->Target);
          isset_Target = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast159;
          xfer += iprot->readI32(ecast159);
          this->Type = (MPhysicsInteractionType::type)ecast159;
          isset_Type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->Values.clear();
            uint32_t _size160;
            ::apache::thrift::protocol::TType _etype163;
            xfer += iprot->readListBegin(_etype163, _size160);
            this->Values.resize(_size160);
            uint32_t _i164;
            for (_i164 = 0; _i164 < _size160; ++_i164)
            {
              xfer += iprot->readDouble(this->Values[_i164]);
            }
            xfer += iprot->readListEnd();
          }
          isset_Values = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->Properties.clear();
            uint32_t _size165;
            ::apache::thrift::protocol::TType _ktype166;
            ::apache::thrift::protocol::TType _vtype167;
            xfer += iprot->readMapBegin(_ktype166, _vtype167, _size165);
            uint32_t _i169;
            for (_i169 = 0; _i169 < _size165; ++_i169)
            {
              std::string _key170;
              xfer += iprot->readString(_key170);
              std::string& _val171 = this->Properties[_key170];
              xfer += iprot->readString(_val171);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.Properties = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_Target)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_Type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_Values)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t MPhysicsInteraction::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MPhysicsInteraction");

  xfer += oprot->writeFieldBegin("Target", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->Target);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("Type", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->Type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("Values", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(this->Values.size()));
    std::vector<double> ::const_iterator _iter172;
    for (_iter172 = this->Values.begin(); _iter172 != this->Values.end(); ++_iter172)
    {
      xfer += oprot->writeDouble((*_iter172));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.Properties) {
    xfer += oprot->writeFieldBegin("Properties", ::apache::thrift::protocol::T_MAP, 4);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->Properties.size()));
      std::map<std::string, std::string> ::const_iterator _iter173;
      for (_iter173 = this->Properties.begin(); _iter173 != this->Properties.end(); ++_iter173)
      {
        xfer += oprot->writeString(_iter173->first);
        xfer += oprot->writeString(_iter173->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MPhysicsInteraction &a, MPhysicsInteraction &b) {
  using ::std::swap;
  swap(a.Target, b.Target);
  swap(a.Type, b.Type);
  swap(a.Values, b.Values);
  swap(a.Properties, b.Properties);
  swap(a.__isset, b.__isset);
}

MPhysicsInteraction::MPhysicsInteraction(const MPhysicsInteraction& other174) {
  Target = other174.Target;
  Type = other174.Type;
  Values = other174.Values;
  Properties = other174.Properties;
  __isset = other174.__isset;
}
MPhysicsInteraction& MPhysicsInteraction::operator=(const MPhysicsInteraction& other175) {
  Target = other175.Target;
  Type = other175.Type;
  Values = other175.Values;
  Properties = other175.Properties;
  __isset = other175.__isset;
  return *this;
}
void MPhysicsInteraction::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MPhysicsInteraction(";
  out << "Target=" << to_string(Target);
  out << ", " << "Type=" << to_string(Type);
  out << ", " << "Values=" << to_string(Values);
  out << ", " << "Properties="; (__isset.Properties ? (out << to_string(Properties)) : (out << "<null>"));
  out << ")";
}


MSceneManipulation::~MSceneManipulation() noexcept {
}


void MSceneManipulation::__set_Transforms(const std::vector<MTransformManipulation> & val) {
  this->Transforms = val;
__isset.Transforms = true;
}

void MSceneManipulation::__set_PhysicsInteractions(const std::vector<MPhysicsInteraction> & val) {
  this->PhysicsInteractions = val;
__isset.PhysicsInteractions = true;
}

void MSceneManipulation::__set_Properties(const std::vector<MPropertyManipulation> & val) {
  this->Properties = val;
__isset.Properties = true;
}

void MSceneManipulation::__set_Attachments(const std::vector<MAttachmentManipulation> & val) {
  this->Attachments = val;
__isset.Attachments = true;
}
std::ostream& operator<<(std::ostream& out, const MSceneManipulation& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t MSceneManipulation::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->Transforms.clear();
            uint32_t _size176;
            ::apache::thrift::protocol::TType _etype179;
            xfer += iprot->readListBegin(_etype179, _size176);
            this->Transforms.resize(_size176);
            uint32_t _i180;
            for (_i180 = 0; _i180 < _size176; ++_i180)
            {
              xfer += this->Transforms[_i180].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.Transforms = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->PhysicsInteractions.clear();
            uint32_t _size181;
            ::apache::thrift::protocol::TType _etype184;
            xfer += iprot->readListBegin(_etype184, _size181);
            this->PhysicsInteractions.resize(_size181);
            uint32_t _i185;
            for (_i185 = 0; _i185 < _size181; ++_i185)
            {
              xfer += this->PhysicsInteractions[_i185].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.PhysicsInteractions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->Properties.clear();
            uint32_t _size186;
            ::apache::thrift::protocol::TType _etype189;
            xfer += iprot->readListBegin(_etype189, _size186);
            this->Properties.resize(_size186);
            uint32_t _i190;
            for (_i190 = 0; _i190 < _size186; ++_i190)
            {
              xfer += this->Properties[_i190].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.Properties = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->Attachments.clear();
            uint32_t _size191;
            ::apache::thrift::protocol::TType _etype194;
            xfer += iprot->readListBegin(_etype194, _size191);
            this->Attachments.resize(_size191);
            uint32_t _i195;
            for (_i195 = 0; _i195 < _size191; ++_i195)
            {
              xfer += this->Attachments[_i195].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.Attachments = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MSceneManipulation::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MSceneManipulation");

  if (this->__isset.Transforms) {
    xfer += oprot->writeFieldBegin("Transforms", ::apache::thrift::protocol::T_LIST, 1);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->Transforms.size()));
      std::vector<MTransformManipulation> ::const_iterator _iter196;
      for (_iter196 = this->Transforms.begin(); _iter196 != this->Transforms.end(); ++_iter196)
      {
        xfer += (*_iter196).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.PhysicsInteractions) {
    xfer += oprot->writeFieldBegin("PhysicsInteractions", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->PhysicsInteractions.size()));
      std::vector<MPhysicsInteraction> ::const_iterator _iter197;
      for (_iter197 = this->PhysicsInteractions.begin(); _iter197 != this->PhysicsInteractions.end(); ++_iter197)
      {
        xfer += (*_iter197).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.Properties) {
    xfer += oprot->writeFieldBegin("Properties", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->Properties.size()));
      std::vector<MPropertyManipulation> ::const_iterator _iter198;
      for (_iter198 = this->Properties.begin(); _iter198 != this->Properties.end(); ++_iter198)
      {
        xfer += (*_iter198).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.Attachments) {
    xfer += oprot->writeFieldBegin("Attachments", ::apache::thrift::protocol::T_LIST, 4);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->Attachments.size()));
      std::vector<MAttachmentManipulation> ::const_iterator _iter199;
      for (_iter199 = this->Attachments.begin(); _iter199 != this->Attachments.end(); ++_iter199)
      {
        xfer += (*_iter199).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MSceneManipulation &a, MSceneManipulation &b) {
  using ::std::swap;
  swap(a.Transforms, b.Transforms);
  swap(a.PhysicsInteractions, b.PhysicsInteractions);
  swap(a.Properties, b.Properties);
  swap(a.Attachments, b.Attachments);
  swap(a.__isset, b.__isset);
}

MSceneManipulation::MSceneManipulation(const MSceneManipulation& other200) {
  Transforms = other200.Transforms;
  PhysicsInteractions = other200.PhysicsInteractions;
  Properties = other200.Properties;
  Attachments = other200.Attachments;
  __isset = other200.__isset;
}
MSceneManipulation& MSceneManipulation::operator=(const MSceneManipulation& other201) {
  Transforms = other201.Transforms;
  PhysicsInteractions = other201.PhysicsInteractions;
  Properties = other201.Properties;
  Attachments = other201.Attachments;
  __isset = other201.__isset;
  return *this;
}
void MSceneManipulation::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MSceneManipulation(";
  out << "Transforms="; (__isset.Transforms ? (out << to_string(Transforms)) : (out << "<null>"));
  out << ", " << "PhysicsInteractions="; (__isset.PhysicsInteractions ? (out << to_string(PhysicsInteractions)) : (out << "<null>"));
  out << ", " << "Properties="; (__isset.Properties ? (out << to_string(Properties)) : (out << "<null>"));
  out << ", " << "Attachments="; (__isset.Attachments ? (out << to_string(Attachments)) : (out << "<null>"));
  out << ")";
}


MCollider::~MCollider() noexcept {
}


void MCollider::__set_ID(const std::string& val) {
  this->ID = val;
}

void MCollider::__set_Type(const MColliderType::type val) {
  this->Type = val;
}

void MCollider::__set_BoxColliderProperties(const MBoxColliderProperties& val) {
  this->BoxColliderProperties = val;
__isset.BoxColliderProperties = true;
}

void MCollider::__set_SphereColliderProperties(const MSphereColliderProperties& val) {
  this->SphereColliderProperties = val;
__isset.SphereColliderProperties = true;
}

void MCollider::__set_CapsuleColliderProperties(const MCapsuleColliderProperties& val) {
  this->CapsuleColliderProperties = val;
__isset.CapsuleColliderProperties = true;
}

void MCollider::__set_ConeColliderProperties(const MConeColliderProperties& val) {
  this->ConeColliderProperties = val;
__isset.ConeColliderProperties = true;
}

void MCollider::__set_CylinderColliderProperties(const MCylinderColliderProperties& val) {
  this->CylinderColliderProperties = val;
__isset.CylinderColliderProperties = true;
}

void MCollider::__set_MeshColliderProperties(const MMeshColliderProperties& val) {
  this->MeshColliderProperties = val;
__isset.MeshColliderProperties = true;
}

void MCollider::__set_PositionOffset(const  ::MMIStandard::MVector3& val) {
  this->PositionOffset = val;
__isset.PositionOffset = true;
}

void MCollider::__set_RotationOffset(const  ::MMIStandard::MQuaternion& val) {
  this->RotationOffset = val;
__isset.RotationOffset = true;
}

void MCollider::__set_Colliders(const std::vector<MCollider> & val) {
  this->Colliders = val;
__isset.Colliders = true;
}

void MCollider::__set_Properties(const std::map<std::string, std::string> & val) {
  this->Properties = val;
__isset.Properties = true;
}
std::ostream& operator<<(std::ostream& out, const MCollider& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t MCollider::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_ID = false;
  bool isset_Type = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ID);
          isset_ID = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast202;
          xfer += iprot->readI32(ecast202);
          this->Type = (MColliderType::type)ecast202;
          isset_Type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->BoxColliderProperties.read(iprot);
          this->__isset.BoxColliderProperties = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->SphereColliderProperties.read(iprot);
          this->__isset.SphereColliderProperties = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->CapsuleColliderProperties.read(iprot);
          this->__isset.CapsuleColliderProperties = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ConeColliderProperties.read(iprot);
          this->__isset.ConeColliderProperties = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->CylinderColliderProperties.read(iprot);
          this->__isset.CylinderColliderProperties = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->MeshColliderProperties.read(iprot);
          this->__isset.MeshColliderProperties = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->PositionOffset.read(iprot);
          this->__isset.PositionOffset = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->RotationOffset.read(iprot);
          this->__isset.RotationOffset = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->Colliders.clear();
            uint32_t _size203;
            ::apache::thrift::protocol::TType _etype206;
            xfer += iprot->readListBegin(_etype206, _size203);
            this->Colliders.resize(_size203);
            uint32_t _i207;
            for (_i207 = 0; _i207 < _size203; ++_i207)
            {
              xfer += this->Colliders[_i207].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.Colliders = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->Properties.clear();
            uint32_t _size208;
            ::apache::thrift::protocol::TType _ktype209;
            ::apache::thrift::protocol::TType _vtype210;
            xfer += iprot->readMapBegin(_ktype209, _vtype210, _size208);
            uint32_t _i212;
            for (_i212 = 0; _i212 < _size208; ++_i212)
            {
              std::string _key213;
              xfer += iprot->readString(_key213);
              std::string& _val214 = this->Properties[_key213];
              xfer += iprot->readString(_val214);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.Properties = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_ID)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_Type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t MCollider::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MCollider");

  xfer += oprot->writeFieldBegin("ID", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->ID);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("Type", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->Type);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.BoxColliderProperties) {
    xfer += oprot->writeFieldBegin("BoxColliderProperties", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->BoxColliderProperties.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.SphereColliderProperties) {
    xfer += oprot->writeFieldBegin("SphereColliderProperties", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->SphereColliderProperties.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.CapsuleColliderProperties) {
    xfer += oprot->writeFieldBegin("CapsuleColliderProperties", ::apache::thrift::protocol::T_STRUCT, 5);
    xfer += this->CapsuleColliderProperties.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ConeColliderProperties) {
    xfer += oprot->writeFieldBegin("ConeColliderProperties", ::apache::thrift::protocol::T_STRUCT, 6);
    xfer += this->ConeColliderProperties.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.CylinderColliderProperties) {
    xfer += oprot->writeFieldBegin("CylinderColliderProperties", ::apache::thrift::protocol::T_STRUCT, 7);
    xfer += this->CylinderColliderProperties.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.MeshColliderProperties) {
    xfer += oprot->writeFieldBegin("MeshColliderProperties", ::apache::thrift::protocol::T_STRUCT, 8);
    xfer += this->MeshColliderProperties.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.PositionOffset) {
    xfer += oprot->writeFieldBegin("PositionOffset", ::apache::thrift::protocol::T_STRUCT, 9);
    xfer += this->PositionOffset.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.RotationOffset) {
    xfer += oprot->writeFieldBegin("RotationOffset", ::apache::thrift::protocol::T_STRUCT, 10);
    xfer += this->RotationOffset.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.Colliders) {
    xfer += oprot->writeFieldBegin("Colliders", ::apache::thrift::protocol::T_LIST, 11);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->Colliders.size()));
      std::vector<MCollider> ::const_iterator _iter215;
      for (_iter215 = this->Colliders.begin(); _iter215 != this->Colliders.end(); ++_iter215)
      {
        xfer += (*_iter215).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.Properties) {
    xfer += oprot->writeFieldBegin("Properties", ::apache::thrift::protocol::T_MAP, 12);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->Properties.size()));
      std::map<std::string, std::string> ::const_iterator _iter216;
      for (_iter216 = this->Properties.begin(); _iter216 != this->Properties.end(); ++_iter216)
      {
        xfer += oprot->writeString(_iter216->first);
        xfer += oprot->writeString(_iter216->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MCollider &a, MCollider &b) {
  using ::std::swap;
  swap(a.ID, b.ID);
  swap(a.Type, b.Type);
  swap(a.BoxColliderProperties, b.BoxColliderProperties);
  swap(a.SphereColliderProperties, b.SphereColliderProperties);
  swap(a.CapsuleColliderProperties, b.CapsuleColliderProperties);
  swap(a.ConeColliderProperties, b.ConeColliderProperties);
  swap(a.CylinderColliderProperties, b.CylinderColliderProperties);
  swap(a.MeshColliderProperties, b.MeshColliderProperties);
  swap(a.PositionOffset, b.PositionOffset);
  swap(a.RotationOffset, b.RotationOffset);
  swap(a.Colliders, b.Colliders);
  swap(a.Properties, b.Properties);
  swap(a.__isset, b.__isset);
}

MCollider::MCollider(const MCollider& other217) {
  ID = other217.ID;
  Type = other217.Type;
  BoxColliderProperties = other217.BoxColliderProperties;
  SphereColliderProperties = other217.SphereColliderProperties;
  CapsuleColliderProperties = other217.CapsuleColliderProperties;
  ConeColliderProperties = other217.ConeColliderProperties;
  CylinderColliderProperties = other217.CylinderColliderProperties;
  MeshColliderProperties = other217.MeshColliderProperties;
  PositionOffset = other217.PositionOffset;
  RotationOffset = other217.RotationOffset;
  Colliders = other217.Colliders;
  Properties = other217.Properties;
  __isset = other217.__isset;
}
MCollider& MCollider::operator=(const MCollider& other218) {
  ID = other218.ID;
  Type = other218.Type;
  BoxColliderProperties = other218.BoxColliderProperties;
  SphereColliderProperties = other218.SphereColliderProperties;
  CapsuleColliderProperties = other218.CapsuleColliderProperties;
  ConeColliderProperties = other218.ConeColliderProperties;
  CylinderColliderProperties = other218.CylinderColliderProperties;
  MeshColliderProperties = other218.MeshColliderProperties;
  PositionOffset = other218.PositionOffset;
  RotationOffset = other218.RotationOffset;
  Colliders = other218.Colliders;
  Properties = other218.Properties;
  __isset = other218.__isset;
  return *this;
}
void MCollider::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MCollider(";
  out << "ID=" << to_string(ID);
  out << ", " << "Type=" << to_string(Type);
  out << ", " << "BoxColliderProperties="; (__isset.BoxColliderProperties ? (out << to_string(BoxColliderProperties)) : (out << "<null>"));
  out << ", " << "SphereColliderProperties="; (__isset.SphereColliderProperties ? (out << to_string(SphereColliderProperties)) : (out << "<null>"));
  out << ", " << "CapsuleColliderProperties="; (__isset.CapsuleColliderProperties ? (out << to_string(CapsuleColliderProperties)) : (out << "<null>"));
  out << ", " << "ConeColliderProperties="; (__isset.ConeColliderProperties ? (out << to_string(ConeColliderProperties)) : (out << "<null>"));
  out << ", " << "CylinderColliderProperties="; (__isset.CylinderColliderProperties ? (out << to_string(CylinderColliderProperties)) : (out << "<null>"));
  out << ", " << "MeshColliderProperties="; (__isset.MeshColliderProperties ? (out << to_string(MeshColliderProperties)) : (out << "<null>"));
  out << ", " << "PositionOffset="; (__isset.PositionOffset ? (out << to_string(PositionOffset)) : (out << "<null>"));
  out << ", " << "RotationOffset="; (__isset.RotationOffset ? (out << to_string(RotationOffset)) : (out << "<null>"));
  out << ", " << "Colliders="; (__isset.Colliders ? (out << to_string(Colliders)) : (out << "<null>"));
  out << ", " << "Properties="; (__isset.Properties ? (out << to_string(Properties)) : (out << "<null>"));
  out << ")";
}


MSceneObject::~MSceneObject() noexcept {
}


void MSceneObject::__set_ID(const std::string& val) {
  this->ID = val;
}

void MSceneObject::__set_Name(const std::string& val) {
  this->Name = val;
}

void MSceneObject::__set_Transform(const  ::MMIStandard::MTransform& val) {
  this->Transform = val;
}

void MSceneObject::__set_Collider(const MCollider& val) {
  this->Collider = val;
__isset.Collider = true;
}

void MSceneObject::__set_Mesh(const MMesh& val) {
  this->Mesh = val;
__isset.Mesh = true;
}

void MSceneObject::__set_PhysicsProperties(const MPhysicsProperties& val) {
  this->PhysicsProperties = val;
__isset.PhysicsProperties = true;
}

void MSceneObject::__set_Properties(const std::map<std::string, std::string> & val) {
  this->Properties = val;
__isset.Properties = true;
}

void MSceneObject::__set_Attachments(const std::vector<MAttachment> & val) {
  this->Attachments = val;
__isset.Attachments = true;
}

void MSceneObject::__set_Constraints(const std::vector< ::MMIStandard::MConstraint> & val) {
  this->Constraints = val;
__isset.Constraints = true;
}
std::ostream& operator<<(std::ostream& out, const MSceneObject& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t MSceneObject::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_ID = false;
  bool isset_Name = false;
  bool isset_Transform = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ID);
          isset_ID = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->Name);
          isset_Name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->Transform.read(iprot);
          isset_Transform = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->Collider.read(iprot);
          this->__isset.Collider = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->Mesh.read(iprot);
          this->__isset.Mesh = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->PhysicsProperties.read(iprot);
          this->__isset.PhysicsProperties = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->Properties.clear();
            uint32_t _size219;
            ::apache::thrift::protocol::TType _ktype220;
            ::apache::thrift::protocol::TType _vtype221;
            xfer += iprot->readMapBegin(_ktype220, _vtype221, _size219);
            uint32_t _i223;
            for (_i223 = 0; _i223 < _size219; ++_i223)
            {
              std::string _key224;
              xfer += iprot->readString(_key224);
              std::string& _val225 = this->Properties[_key224];
              xfer += iprot->readString(_val225);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.Properties = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->Attachments.clear();
            uint32_t _size226;
            ::apache::thrift::protocol::TType _etype229;
            xfer += iprot->readListBegin(_etype229, _size226);
            this->Attachments.resize(_size226);
            uint32_t _i230;
            for (_i230 = 0; _i230 < _size226; ++_i230)
            {
              xfer += this->Attachments[_i230].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.Attachments = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->Constraints.clear();
            uint32_t _size231;
            ::apache::thrift::protocol::TType _etype234;
            xfer += iprot->readListBegin(_etype234, _size231);
            this->Constraints.resize(_size231);
            uint32_t _i235;
            for (_i235 = 0; _i235 < _size231; ++_i235)
            {
              xfer += this->Constraints[_i235].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.Constraints = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_ID)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_Name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_Transform)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t MSceneObject::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MSceneObject");

  xfer += oprot->writeFieldBegin("ID", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->ID);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("Name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->Name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("Transform", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->Transform.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.Collider) {
    xfer += oprot->writeFieldBegin("Collider", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->Collider.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.Mesh) {
    xfer += oprot->writeFieldBegin("Mesh", ::apache::thrift::protocol::T_STRUCT, 5);
    xfer += this->Mesh.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.PhysicsProperties) {
    xfer += oprot->writeFieldBegin("PhysicsProperties", ::apache::thrift::protocol::T_STRUCT, 6);
    xfer += this->PhysicsProperties.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.Properties) {
    xfer += oprot->writeFieldBegin("Properties", ::apache::thrift::protocol::T_MAP, 8);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->Properties.size()));
      std::map<std::string, std::string> ::const_iterator _iter236;
      for (_iter236 = this->Properties.begin(); _iter236 != this->Properties.end(); ++_iter236)
      {
        xfer += oprot->writeString(_iter236->first);
        xfer += oprot->writeString(_iter236->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.Attachments) {
    xfer += oprot->writeFieldBegin("Attachments", ::apache::thrift::protocol::T_LIST, 9);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->Attachments.size()));
      std::vector<MAttachment> ::const_iterator _iter237;
      for (_iter237 = this->Attachments.begin(); _iter237 != this->Attachments.end(); ++_iter237)
      {
        xfer += (*_iter237).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.Constraints) {
    xfer += oprot->writeFieldBegin("Constraints", ::apache::thrift::protocol::T_LIST, 10);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->Constraints.size()));
      std::vector< ::MMIStandard::MConstraint> ::const_iterator _iter238;
      for (_iter238 = this->Constraints.begin(); _iter238 != this->Constraints.end(); ++_iter238)
      {
        xfer += (*_iter238).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MSceneObject &a, MSceneObject &b) {
  using ::std::swap;
  swap(a.ID, b.ID);
  swap(a.Name, b.Name);
  swap(a.Transform, b.Transform);
  swap(a.Collider, b.Collider);
  swap(a.Mesh, b.Mesh);
  swap(a.PhysicsProperties, b.PhysicsProperties);
  swap(a.Properties, b.Properties);
  swap(a.Attachments, b.Attachments);
  swap(a.Constraints, b.Constraints);
  swap(a.__isset, b.__isset);
}

MSceneObject::MSceneObject(const MSceneObject& other239) {
  ID = other239.ID;
  Name = other239.Name;
  Transform = other239.Transform;
  Collider = other239.Collider;
  Mesh = other239.Mesh;
  PhysicsProperties = other239.PhysicsProperties;
  Properties = other239.Properties;
  Attachments = other239.Attachments;
  Constraints = other239.Constraints;
  __isset = other239.__isset;
}
MSceneObject& MSceneObject::operator=(const MSceneObject& other240) {
  ID = other240.ID;
  Name = other240.Name;
  Transform = other240.Transform;
  Collider = other240.Collider;
  Mesh = other240.Mesh;
  PhysicsProperties = other240.PhysicsProperties;
  Properties = other240.Properties;
  Attachments = other240.Attachments;
  Constraints = other240.Constraints;
  __isset = other240.__isset;
  return *this;
}
void MSceneObject::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MSceneObject(";
  out << "ID=" << to_string(ID);
  out << ", " << "Name=" << to_string(Name);
  out << ", " << "Transform=" << to_string(Transform);
  out << ", " << "Collider="; (__isset.Collider ? (out << to_string(Collider)) : (out << "<null>"));
  out << ", " << "Mesh="; (__isset.Mesh ? (out << to_string(Mesh)) : (out << "<null>"));
  out << ", " << "PhysicsProperties="; (__isset.PhysicsProperties ? (out << to_string(PhysicsProperties)) : (out << "<null>"));
  out << ", " << "Properties="; (__isset.Properties ? (out << to_string(Properties)) : (out << "<null>"));
  out << ", " << "Attachments="; (__isset.Attachments ? (out << to_string(Attachments)) : (out << "<null>"));
  out << ", " << "Constraints="; (__isset.Constraints ? (out << to_string(Constraints)) : (out << "<null>"));
  out << ")";
}


MSceneObjectUpdate::~MSceneObjectUpdate() noexcept {
}


void MSceneObjectUpdate::__set_ID(const std::string& val) {
  this->ID = val;
}

void MSceneObjectUpdate::__set_Name(const std::string& val) {
  this->Name = val;
__isset.Name = true;
}

void MSceneObjectUpdate::__set_Transform(const MTransformUpdate& val) {
  this->Transform = val;
__isset.Transform = true;
}

void MSceneObjectUpdate::__set_Collider(const MCollider& val) {
  this->Collider = val;
__isset.Collider = true;
}

void MSceneObjectUpdate::__set_Mesh(const MMesh& val) {
  this->Mesh = val;
__isset.Mesh = true;
}

void MSceneObjectUpdate::__set_PhysicsProperties(const MPhysicsProperties& val) {
  this->PhysicsProperties = val;
__isset.PhysicsProperties = true;
}

void MSceneObjectUpdate::__set_HandPoses(const std::vector< ::MMIStandard::MHandPose> & val) {
  this->HandPoses = val;
__isset.HandPoses = true;
}

void MSceneObjectUpdate::__set_Properties(const std::vector<MPropertyUpdate> & val) {
  this->Properties = val;
__isset.Properties = true;
}

void MSceneObjectUpdate::__set_Attachments(const std::vector<MAttachment> & val) {
  this->Attachments = val;
__isset.Attachments = true;
}

void MSceneObjectUpdate::__set_Constraints(const std::vector< ::MMIStandard::MConstraint> & val) {
  this->Constraints = val;
__isset.Constraints = true;
}
std::ostream& operator<<(std::ostream& out, const MSceneObjectUpdate& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t MSceneObjectUpdate::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_ID = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ID);
          isset_ID = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->Name);
          this->__isset.Name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->Transform.read(iprot);
          this->__isset.Transform = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->Collider.read(iprot);
          this->__isset.Collider = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->Mesh.read(iprot);
          this->__isset.Mesh = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->PhysicsProperties.read(iprot);
          this->__isset.PhysicsProperties = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->HandPoses.clear();
            uint32_t _size241;
            ::apache::thrift::protocol::TType _etype244;
            xfer += iprot->readListBegin(_etype244, _size241);
            this->HandPoses.resize(_size241);
            uint32_t _i245;
            for (_i245 = 0; _i245 < _size241; ++_i245)
            {
              xfer += this->HandPoses[_i245].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.HandPoses = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->Properties.clear();
            uint32_t _size246;
            ::apache::thrift::protocol::TType _etype249;
            xfer += iprot->readListBegin(_etype249, _size246);
            this->Properties.resize(_size246);
            uint32_t _i250;
            for (_i250 = 0; _i250 < _size246; ++_i250)
            {
              xfer += this->Properties[_i250].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.Properties = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->Attachments.clear();
            uint32_t _size251;
            ::apache::thrift::protocol::TType _etype254;
            xfer += iprot->readListBegin(_etype254, _size251);
            this->Attachments.resize(_size251);
            uint32_t _i255;
            for (_i255 = 0; _i255 < _size251; ++_i255)
            {
              xfer += this->Attachments[_i255].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.Attachments = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->Constraints.clear();
            uint32_t _size256;
            ::apache::thrift::protocol::TType _etype259;
            xfer += iprot->readListBegin(_etype259, _size256);
            this->Constraints.resize(_size256);
            uint32_t _i260;
            for (_i260 = 0; _i260 < _size256; ++_i260)
            {
              xfer += this->Constraints[_i260].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.Constraints = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_ID)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t MSceneObjectUpdate::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MSceneObjectUpdate");

  xfer += oprot->writeFieldBegin("ID", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->ID);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.Name) {
    xfer += oprot->writeFieldBegin("Name", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->Name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.Transform) {
    xfer += oprot->writeFieldBegin("Transform", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->Transform.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.Collider) {
    xfer += oprot->writeFieldBegin("Collider", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->Collider.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.Mesh) {
    xfer += oprot->writeFieldBegin("Mesh", ::apache::thrift::protocol::T_STRUCT, 5);
    xfer += this->Mesh.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.PhysicsProperties) {
    xfer += oprot->writeFieldBegin("PhysicsProperties", ::apache::thrift::protocol::T_STRUCT, 6);
    xfer += this->PhysicsProperties.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.HandPoses) {
    xfer += oprot->writeFieldBegin("HandPoses", ::apache::thrift::protocol::T_LIST, 7);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->HandPoses.size()));
      std::vector< ::MMIStandard::MHandPose> ::const_iterator _iter261;
      for (_iter261 = this->HandPoses.begin(); _iter261 != this->HandPoses.end(); ++_iter261)
      {
        xfer += (*_iter261).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.Properties) {
    xfer += oprot->writeFieldBegin("Properties", ::apache::thrift::protocol::T_LIST, 8);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->Properties.size()));
      std::vector<MPropertyUpdate> ::const_iterator _iter262;
      for (_iter262 = this->Properties.begin(); _iter262 != this->Properties.end(); ++_iter262)
      {
        xfer += (*_iter262).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.Attachments) {
    xfer += oprot->writeFieldBegin("Attachments", ::apache::thrift::protocol::T_LIST, 9);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->Attachments.size()));
      std::vector<MAttachment> ::const_iterator _iter263;
      for (_iter263 = this->Attachments.begin(); _iter263 != this->Attachments.end(); ++_iter263)
      {
        xfer += (*_iter263).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.Constraints) {
    xfer += oprot->writeFieldBegin("Constraints", ::apache::thrift::protocol::T_LIST, 10);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->Constraints.size()));
      std::vector< ::MMIStandard::MConstraint> ::const_iterator _iter264;
      for (_iter264 = this->Constraints.begin(); _iter264 != this->Constraints.end(); ++_iter264)
      {
        xfer += (*_iter264).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MSceneObjectUpdate &a, MSceneObjectUpdate &b) {
  using ::std::swap;
  swap(a.ID, b.ID);
  swap(a.Name, b.Name);
  swap(a.Transform, b.Transform);
  swap(a.Collider, b.Collider);
  swap(a.Mesh, b.Mesh);
  swap(a.PhysicsProperties, b.PhysicsProperties);
  swap(a.HandPoses, b.HandPoses);
  swap(a.Properties, b.Properties);
  swap(a.Attachments, b.Attachments);
  swap(a.Constraints, b.Constraints);
  swap(a.__isset, b.__isset);
}

MSceneObjectUpdate::MSceneObjectUpdate(const MSceneObjectUpdate& other265) {
  ID = other265.ID;
  Name = other265.Name;
  Transform = other265.Transform;
  Collider = other265.Collider;
  Mesh = other265.Mesh;
  PhysicsProperties = other265.PhysicsProperties;
  HandPoses = other265.HandPoses;
  Properties = other265.Properties;
  Attachments = other265.Attachments;
  Constraints = other265.Constraints;
  __isset = other265.__isset;
}
MSceneObjectUpdate& MSceneObjectUpdate::operator=(const MSceneObjectUpdate& other266) {
  ID = other266.ID;
  Name = other266.Name;
  Transform = other266.Transform;
  Collider = other266.Collider;
  Mesh = other266.Mesh;
  PhysicsProperties = other266.PhysicsProperties;
  HandPoses = other266.HandPoses;
  Properties = other266.Properties;
  Attachments = other266.Attachments;
  Constraints = other266.Constraints;
  __isset = other266.__isset;
  return *this;
}
void MSceneObjectUpdate::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MSceneObjectUpdate(";
  out << "ID=" << to_string(ID);
  out << ", " << "Name="; (__isset.Name ? (out << to_string(Name)) : (out << "<null>"));
  out << ", " << "Transform="; (__isset.Transform ? (out << to_string(Transform)) : (out << "<null>"));
  out << ", " << "Collider="; (__isset.Collider ? (out << to_string(Collider)) : (out << "<null>"));
  out << ", " << "Mesh="; (__isset.Mesh ? (out << to_string(Mesh)) : (out << "<null>"));
  out << ", " << "PhysicsProperties="; (__isset.PhysicsProperties ? (out << to_string(PhysicsProperties)) : (out << "<null>"));
  out << ", " << "HandPoses="; (__isset.HandPoses ? (out << to_string(HandPoses)) : (out << "<null>"));
  out << ", " << "Properties="; (__isset.Properties ? (out << to_string(Properties)) : (out << "<null>"));
  out << ", " << "Attachments="; (__isset.Attachments ? (out << to_string(Attachments)) : (out << "<null>"));
  out << ", " << "Constraints="; (__isset.Constraints ? (out << to_string(Constraints)) : (out << "<null>"));
  out << ")";
}


MSceneUpdate::~MSceneUpdate() noexcept {
}


void MSceneUpdate::__set_AddedSceneObjects(const std::vector<MSceneObject> & val) {
  this->AddedSceneObjects = val;
__isset.AddedSceneObjects = true;
}

void MSceneUpdate::__set_ChangedSceneObjects(const std::vector<MSceneObjectUpdate> & val) {
  this->ChangedSceneObjects = val;
__isset.ChangedSceneObjects = true;
}

void MSceneUpdate::__set_RemovedSceneObjects(const std::vector<std::string> & val) {
  this->RemovedSceneObjects = val;
__isset.RemovedSceneObjects = true;
}

void MSceneUpdate::__set_AddedAvatars(const std::vector< ::MMIStandard::MAvatar> & val) {
  this->AddedAvatars = val;
__isset.AddedAvatars = true;
}

void MSceneUpdate::__set_ChangedAvatars(const std::vector<MAvatarUpdate> & val) {
  this->ChangedAvatars = val;
__isset.ChangedAvatars = true;
}

void MSceneUpdate::__set_RemovedAvatars(const std::vector<std::string> & val) {
  this->RemovedAvatars = val;
__isset.RemovedAvatars = true;
}
std::ostream& operator<<(std::ostream& out, const MSceneUpdate& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t MSceneUpdate::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->AddedSceneObjects.clear();
            uint32_t _size267;
            ::apache::thrift::protocol::TType _etype270;
            xfer += iprot->readListBegin(_etype270, _size267);
            this->AddedSceneObjects.resize(_size267);
            uint32_t _i271;
            for (_i271 = 0; _i271 < _size267; ++_i271)
            {
              xfer += this->AddedSceneObjects[_i271].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.AddedSceneObjects = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->ChangedSceneObjects.clear();
            uint32_t _size272;
            ::apache::thrift::protocol::TType _etype275;
            xfer += iprot->readListBegin(_etype275, _size272);
            this->ChangedSceneObjects.resize(_size272);
            uint32_t _i276;
            for (_i276 = 0; _i276 < _size272; ++_i276)
            {
              xfer += this->ChangedSceneObjects[_i276].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.ChangedSceneObjects = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->RemovedSceneObjects.clear();
            uint32_t _size277;
            ::apache::thrift::protocol::TType _etype280;
            xfer += iprot->readListBegin(_etype280, _size277);
            this->RemovedSceneObjects.resize(_size277);
            uint32_t _i281;
            for (_i281 = 0; _i281 < _size277; ++_i281)
            {
              xfer += iprot->readString(this->RemovedSceneObjects[_i281]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.RemovedSceneObjects = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->AddedAvatars.clear();
            uint32_t _size282;
            ::apache::thrift::protocol::TType _etype285;
            xfer += iprot->readListBegin(_etype285, _size282);
            this->AddedAvatars.resize(_size282);
            uint32_t _i286;
            for (_i286 = 0; _i286 < _size282; ++_i286)
            {
              xfer += this->AddedAvatars[_i286].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.AddedAvatars = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->ChangedAvatars.clear();
            uint32_t _size287;
            ::apache::thrift::protocol::TType _etype290;
            xfer += iprot->readListBegin(_etype290, _size287);
            this->ChangedAvatars.resize(_size287);
            uint32_t _i291;
            for (_i291 = 0; _i291 < _size287; ++_i291)
            {
              xfer += this->ChangedAvatars[_i291].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.ChangedAvatars = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->RemovedAvatars.clear();
            uint32_t _size292;
            ::apache::thrift::protocol::TType _etype295;
            xfer += iprot->readListBegin(_etype295, _size292);
            this->RemovedAvatars.resize(_size292);
            uint32_t _i296;
            for (_i296 = 0; _i296 < _size292; ++_i296)
            {
              xfer += iprot->readString(this->RemovedAvatars[_i296]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.RemovedAvatars = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MSceneUpdate::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MSceneUpdate");

  if (this->__isset.AddedSceneObjects) {
    xfer += oprot->writeFieldBegin("AddedSceneObjects", ::apache::thrift::protocol::T_LIST, 1);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->AddedSceneObjects.size()));
      std::vector<MSceneObject> ::const_iterator _iter297;
      for (_iter297 = this->AddedSceneObjects.begin(); _iter297 != this->AddedSceneObjects.end(); ++_iter297)
      {
        xfer += (*_iter297).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ChangedSceneObjects) {
    xfer += oprot->writeFieldBegin("ChangedSceneObjects", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->ChangedSceneObjects.size()));
      std::vector<MSceneObjectUpdate> ::const_iterator _iter298;
      for (_iter298 = this->ChangedSceneObjects.begin(); _iter298 != this->ChangedSceneObjects.end(); ++_iter298)
      {
        xfer += (*_iter298).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.RemovedSceneObjects) {
    xfer += oprot->writeFieldBegin("RemovedSceneObjects", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->RemovedSceneObjects.size()));
      std::vector<std::string> ::const_iterator _iter299;
      for (_iter299 = this->RemovedSceneObjects.begin(); _iter299 != this->RemovedSceneObjects.end(); ++_iter299)
      {
        xfer += oprot->writeString((*_iter299));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.AddedAvatars) {
    xfer += oprot->writeFieldBegin("AddedAvatars", ::apache::thrift::protocol::T_LIST, 5);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->AddedAvatars.size()));
      std::vector< ::MMIStandard::MAvatar> ::const_iterator _iter300;
      for (_iter300 = this->AddedAvatars.begin(); _iter300 != this->AddedAvatars.end(); ++_iter300)
      {
        xfer += (*_iter300).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ChangedAvatars) {
    xfer += oprot->writeFieldBegin("ChangedAvatars", ::apache::thrift::protocol::T_LIST, 6);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->ChangedAvatars.size()));
      std::vector<MAvatarUpdate> ::const_iterator _iter301;
      for (_iter301 = this->ChangedAvatars.begin(); _iter301 != this->ChangedAvatars.end(); ++_iter301)
      {
        xfer += (*_iter301).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.RemovedAvatars) {
    xfer += oprot->writeFieldBegin("RemovedAvatars", ::apache::thrift::protocol::T_LIST, 7);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->RemovedAvatars.size()));
      std::vector<std::string> ::const_iterator _iter302;
      for (_iter302 = this->RemovedAvatars.begin(); _iter302 != this->RemovedAvatars.end(); ++_iter302)
      {
        xfer += oprot->writeString((*_iter302));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MSceneUpdate &a, MSceneUpdate &b) {
  using ::std::swap;
  swap(a.AddedSceneObjects, b.AddedSceneObjects);
  swap(a.ChangedSceneObjects, b.ChangedSceneObjects);
  swap(a.RemovedSceneObjects, b.RemovedSceneObjects);
  swap(a.AddedAvatars, b.AddedAvatars);
  swap(a.ChangedAvatars, b.ChangedAvatars);
  swap(a.RemovedAvatars, b.RemovedAvatars);
  swap(a.__isset, b.__isset);
}

MSceneUpdate::MSceneUpdate(const MSceneUpdate& other303) {
  AddedSceneObjects = other303.AddedSceneObjects;
  ChangedSceneObjects = other303.ChangedSceneObjects;
  RemovedSceneObjects = other303.RemovedSceneObjects;
  AddedAvatars = other303.AddedAvatars;
  ChangedAvatars = other303.ChangedAvatars;
  RemovedAvatars = other303.RemovedAvatars;
  __isset = other303.__isset;
}
MSceneUpdate& MSceneUpdate::operator=(const MSceneUpdate& other304) {
  AddedSceneObjects = other304.AddedSceneObjects;
  ChangedSceneObjects = other304.ChangedSceneObjects;
  RemovedSceneObjects = other304.RemovedSceneObjects;
  AddedAvatars = other304.AddedAvatars;
  ChangedAvatars = other304.ChangedAvatars;
  RemovedAvatars = other304.RemovedAvatars;
  __isset = other304.__isset;
  return *this;
}
void MSceneUpdate::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MSceneUpdate(";
  out << "AddedSceneObjects="; (__isset.AddedSceneObjects ? (out << to_string(AddedSceneObjects)) : (out << "<null>"));
  out << ", " << "ChangedSceneObjects="; (__isset.ChangedSceneObjects ? (out << to_string(ChangedSceneObjects)) : (out << "<null>"));
  out << ", " << "RemovedSceneObjects="; (__isset.RemovedSceneObjects ? (out << to_string(RemovedSceneObjects)) : (out << "<null>"));
  out << ", " << "AddedAvatars="; (__isset.AddedAvatars ? (out << to_string(AddedAvatars)) : (out << "<null>"));
  out << ", " << "ChangedAvatars="; (__isset.ChangedAvatars ? (out << to_string(ChangedAvatars)) : (out << "<null>"));
  out << ", " << "RemovedAvatars="; (__isset.RemovedAvatars ? (out << to_string(RemovedAvatars)) : (out << "<null>"));
  out << ")";
}


MAvatarUpdate::~MAvatarUpdate() noexcept {
}


void MAvatarUpdate::__set_ID(const std::string& val) {
  this->ID = val;
}

void MAvatarUpdate::__set_PostureValues(const  ::MMIStandard::MAvatarPostureValues& val) {
  this->PostureValues = val;
__isset.PostureValues = true;
}

void MAvatarUpdate::__set_SceneObjects(const std::vector<std::string> & val) {
  this->SceneObjects = val;
__isset.SceneObjects = true;
}

void MAvatarUpdate::__set_Description(const  ::MMIStandard::MAvatarDescription& val) {
  this->Description = val;
__isset.Description = true;
}

void MAvatarUpdate::__set_Properties(const std::vector<MPropertyUpdate> & val) {
  this->Properties = val;
__isset.Properties = true;
}
std::ostream& operator<<(std::ostream& out, const MAvatarUpdate& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t MAvatarUpdate::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_ID = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ID);
          isset_ID = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->PostureValues.read(iprot);
          this->__isset.PostureValues = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->SceneObjects.clear();
            uint32_t _size305;
            ::apache::thrift::protocol::TType _etype308;
            xfer += iprot->readListBegin(_etype308, _size305);
            this->SceneObjects.resize(_size305);
            uint32_t _i309;
            for (_i309 = 0; _i309 < _size305; ++_i309)
            {
              xfer += iprot->readString(this->SceneObjects[_i309]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.SceneObjects = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->Description.read(iprot);
          this->__isset.Description = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->Properties.clear();
            uint32_t _size310;
            ::apache::thrift::protocol::TType _etype313;
            xfer += iprot->readListBegin(_etype313, _size310);
            this->Properties.resize(_size310);
            uint32_t _i314;
            for (_i314 = 0; _i314 < _size310; ++_i314)
            {
              xfer += this->Properties[_i314].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.Properties = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_ID)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t MAvatarUpdate::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MAvatarUpdate");

  xfer += oprot->writeFieldBegin("ID", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->ID);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.PostureValues) {
    xfer += oprot->writeFieldBegin("PostureValues", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->PostureValues.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.SceneObjects) {
    xfer += oprot->writeFieldBegin("SceneObjects", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->SceneObjects.size()));
      std::vector<std::string> ::const_iterator _iter315;
      for (_iter315 = this->SceneObjects.begin(); _iter315 != this->SceneObjects.end(); ++_iter315)
      {
        xfer += oprot->writeString((*_iter315));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.Description) {
    xfer += oprot->writeFieldBegin("Description", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->Description.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.Properties) {
    xfer += oprot->writeFieldBegin("Properties", ::apache::thrift::protocol::T_LIST, 5);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->Properties.size()));
      std::vector<MPropertyUpdate> ::const_iterator _iter316;
      for (_iter316 = this->Properties.begin(); _iter316 != this->Properties.end(); ++_iter316)
      {
        xfer += (*_iter316).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MAvatarUpdate &a, MAvatarUpdate &b) {
  using ::std::swap;
  swap(a.ID, b.ID);
  swap(a.PostureValues, b.PostureValues);
  swap(a.SceneObjects, b.SceneObjects);
  swap(a.Description, b.Description);
  swap(a.Properties, b.Properties);
  swap(a.__isset, b.__isset);
}

MAvatarUpdate::MAvatarUpdate(const MAvatarUpdate& other317) {
  ID = other317.ID;
  PostureValues = other317.PostureValues;
  SceneObjects = other317.SceneObjects;
  Description = other317.Description;
  Properties = other317.Properties;
  __isset = other317.__isset;
}
MAvatarUpdate& MAvatarUpdate::operator=(const MAvatarUpdate& other318) {
  ID = other318.ID;
  PostureValues = other318.PostureValues;
  SceneObjects = other318.SceneObjects;
  Description = other318.Description;
  Properties = other318.Properties;
  __isset = other318.__isset;
  return *this;
}
void MAvatarUpdate::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MAvatarUpdate(";
  out << "ID=" << to_string(ID);
  out << ", " << "PostureValues="; (__isset.PostureValues ? (out << to_string(PostureValues)) : (out << "<null>"));
  out << ", " << "SceneObjects="; (__isset.SceneObjects ? (out << to_string(SceneObjects)) : (out << "<null>"));
  out << ", " << "Description="; (__isset.Description ? (out << to_string(Description)) : (out << "<null>"));
  out << ", " << "Properties="; (__isset.Properties ? (out << to_string(Properties)) : (out << "<null>"));
  out << ")";
}

} // namespace
